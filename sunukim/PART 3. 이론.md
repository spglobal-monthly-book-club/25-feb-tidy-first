- 코드를 정리해야하는 이유에 대해서 살펴보자.

## CHAPTER 22. 요소들을 유익하게 관계 맺는 일

- 소프트웨어 설계는 인간관계 속에서 벌어지는 활동

- 요소
    - 토큰 -> 식(expression) -> 문(statement) -> 함수(function) -> 객체/모듈(object/module) -> 시스템(system)


    * 참고
        - expression : Expression은 ‘수식’이라는 뜻으로 하나 이상의 값으로 표현(reduce)될 수 있는 코드를 말한다. 
        - statement : statement는 ‘진술’, ‘서술’의 의미로 프로그래밍에서는 실행가능한(executable) 최소의 독립적인 코드 조각을 일컫는다.

- 관계 맺기
    - 하나의 함수가 다른 함수를 호출 합니다.
    - 함수가 바로 그 요소를 이뤄서, '호출하고/호출받는' 관계를 맺습니다.

    - 호출, 발행, 대기, 참조 등이 소프트웨어 설계에서 관계 이다.

- 유익하게
    - 유익하게 해야됨


- 요소들을 유익하게 관계 맺는 일
    - 설계는 구성하는 요소들과 그들의 관계, 그리고 그 관계에서 파생되는 이점이 설게이다.
    - 설계자는 요쇼들을 유익하게 관계 맺는 일을 한다.

    따라서 설계자는 다음 세가지를 한다.
    -> 요소를 만들고 삭제한다.
    -> 관계를 만들고 삭제한다.
    -> 관게의 이점을 높인다.

- 예시

```javascript

const foo = (box) => {
    return box.width() * box.height();
}

-----------------------

box.area = () => {
    return box.width() * box.height();
}

const foo = (box) => {
    return box.area();
}

```

- 설계 관점에서 box.area()라는 새로운 '요소'를 만들고
- foo 함수와 box 객체 사이의 '관계'를 조정했다.
- 두 요소(width, height) 는 하나의 함수 호출로 연결된다.

- foo 함수가 단순하고 유익해진 대가로 box가 하나의 더 커진 함수를 가지게 되었다.

- 결국 시스템의 구조는 아래와 같다.
    - 요소 계층 구조
    - 요소 사이의 관계
    - 이러한 관계가 만들어내는 이점


## CHAPTER 23. 구조와 동작

- 소프트웨어는 두 가지 방식으로 가치를 만든다.
    1. 현재 소프트웨어가 하는 일
    2. 미래에 새로운 일을 시킬 수 있는 가능성

- 현재 소프트웨어가 하는 일 -> 급여 계산, 주문 배송, 친구에게 알림 발송 등의 시스템 '동작'

- 동작을 규정하는 방식
    - 입출력 쌍 : 입력과 출력이 쌍으로 존재 (예시 : 시급과 근무 시간 + 세율 -> 급여와 세금 신고액)
    - 불변 조건 : 같은 의미를 가지는 입력에 대해 항상 같은 출력을 내는 조건? (예시 : 정부가 제공하는 모든 재정지원 하게는 모든 공제액의 합계와 같다.)

- 동작은 가치를 만든다.
- 더 나은 소프트웨어를 만드는 방법 -> 다음에 무엇을 할 수 있는지에 대해 선택할 수 있는 기회를 만들자.
- 선택 가능성이 줄어들면 소프트웨어가 만드는 가치도 줄어든다.
- 그러나 구조에 투자한 것은 동작처럼 또렷하게 드러나지 않는다.
- 일단 구조 변경과 동작 변경이 다르다는 것을 이해하자.
- 되돌릴 수 있는 능력, 가역성에서 차이가 있다.

## CHAPTER 24. 경제 이론: 시간 가치와 선택 가능성

- 소프트웨어 설게는 '먼저 벌고 나중에 써야 한다'와 '물건이 아닌 옵션을 만들어야 한다'는 두 가지 속성을 조화시켜야 한다.

## CHAPTER 25. 오늘의 1달러가 내일의 1달러보다 크다.

- 언제 그리고 얼마나 확실한지가 중요
- 이 책의 범위에서 돈의 시간 가치는 코드 정리를 먼저 하기보다는 나중에 하는 것을 권장
(다만 선행 코드 정리를 하는 경우, 코드 정리 + 동작 변경의 비용 < 동작 변경만 하는 비용)

## CHAPTER 26. 옵션

- 소프트웨어의 미래 현금 흐름을 바꾸는 방법
    - 1. 더 많이, 더 일찍, 더 높은 확률로 돈을 벌자. (수익 ⬆️)
    - 2. 더 적게, 더 늦게, 더 낮은 확률로 돈을 지출하자. (비용 ⬇️)

- 또 다른 가치의 원천 : 옵션
- 확장성을 가지는 것 (옵션을 많이 가지는 것이 큰 가치이다.)

-> 옵션을 만드는 것과 동작을 변경하는 것의 균형을 맞추는 데 집중하자.
    - 잠재적인 동작 변경의 가치가 변동성이 클수록 좋다.
    - 개발 기간이 길면 길수록 좋습니다.
    - 앞으로 더 저렴하게 개발할 수 있다면 좋겠지만, 그것은 가치의 일부에 불과하다.
    - 더 작은 설계 작업으로 옵션을 만들 수 있다면 더 좋다.

## CHAPTER 27. 옵션과 현금흐름 비교

- 현금흐름할인 : 코드 정리를 먼저 하지 말고, 돈부터 벌어라
- 옵션 : 옵션이 생길 일이 명백하다면, 코드 정리를 선행하라

- 코드 정리를 선행해야 할 때 :
    - 코드 정리 비용 + 코드 정리 후 동작 변경 비용 < 바로 동작 변경 비용

- 근데 위 두 판단을 어떻게 하지?
    1. 소프트웨어 설계의 시기와 범위에 영향을 미치는 인센티브를 인식하는 데 익숙해지기
    2. 대인 관계 기술을 우리 자신에게 연습해서, 나중에 밀접하게 일하는 동료부터 더 넓은 범위의 동료에게까지 활용하기

- 위 두 연습을 꾸준히 하다보면, 언제 어떻게 설계해야하고 언제 설게하지 말아야 하는지 직감적으로 알게 된다.

## CHAPTER 28. 되돌릴 수 있는 구조 변경

- 구조 변경이나 되돌릴 수 있게 하자.

## CHAPTER 29. 결합도

- 결합도 : 한 요소를 변경하려면 다른 요소도 변경해야하는 경우, 서로 결합되어있는 것이다.
- 결합도는 소프트웨어 비용을 결정한다.
- 결합도의 성질
    - 1. 일대다 : 어떤 변경이 일어나면, 한 요소는 여러 요소와 결합이 일어납니다.
    - 2. 연쇄작용 : 일단 변경이 일어나면, 한 요소에서 다른 요소로 변경이 파급되고, 그 변경은 그 자체로 또 다른 변경을 촉발하고, 스스로도 변경을 촉발할 수 있습니다.
- 코드 정리에 있어서 결합도의 의미
    - 코드 정리를 할 때, 결합도 때문에 끔찍한 경우가 있다.
    - 잠시 시간을 내어 코드 정리 카탈로그를 살펴보고, 어떤 것이 결합도를 줄일 수 있는지 살펴보자.
    - 결합도는 소프트웨어 비용을 좌우한다.

## CHAPTER 30. 콘스탄틴의 등가성

- 소프트웨어 설계의 목표는 소프트웨어의 비용을 최소화하는 것. 그렇다면 그 비용은 얼마일까?
- 소프트웨어 비용 ~= 변경하는 비용
- 출시 이후에 소프트웨어를 변경하는 비용이 더 많이 나오는데, 고려할 것이 많기 때문이다.
- 전체를 변경하는 비용 ~= 큰 변경들에 대한 비용
- 큰 변경들에 대한 비용이 비싼 이유 => 결합도가 크기 때문에
- 큰 변경들에 대한 비용 ~= 결합도

- 소프트웨어 비용 ~= 전체를 변경하는 비용 ~= 큰 변경들에 대한 비용 ~= 결합도 
=> 소프트웨어 비용 ~= 결합도

- 따라서 소프트웨어 비용을 줄이려면 결합도를 줄여야 한다.
- 하지만 결합도를 줄이는 것은 공짜가 아니다.

## CHAPTER 31. 결합도와 결합도 제거

- 결합도는 왜 생길까?
- 결국에 결합도가 있어도 구현하는 것이 경제적으로 올바르기 때문이다.
- 또, 지금까지 결합도가 있어도 문제되지 않았기 때문이다.
- 마지막으로, 어떤 결합도는 피할 수 없기 때문이다.

- 지금 중요한 것은 결합도 비용을 지불할 것인지, 결합도를 없애는 비용을 지불할 것인지 결정하는 것

- 한 쪽에서 결합도를 줄일 수록, 다른 쪽에서 결합도가 커진다.
- 그래서 모든 결합을 색출하듯 없애려고 애쓰지 말아야 한다.
- 결합도가 적정히 유지되는 선을 지켜보자

## CHAPTER 32. 응집도

- 응집도가 내포하는 의미
    - 1. 결합된 요소들은 둘을 포함하는 같은 요소의 하위요소여야 합니다.
    - 2. 결합되지 않은 요소는 다른 곳으로 이동해야한다.

- 응집도가 없는 요소를 개선하기 위한 두 가지 방법
    - 1. 응집도가 있는 하위 요소를 추출하기
    - 2. 결합되지 않은 하위 요소를 다른 곳으로 보내기

- 1번 방법은 마치 helper 함수를 만드는 것과 같다.
- 2번 방법은 각 함수들을 결합도가 더 높은 쪽으로 배치하는 것과 같다.

- 하지만 즉흥적으로 시도하지는 말자.
- 모든 것을 급격하게 재배치하지 말라.
- 한 번에 한 요소씩 이동하세요. 다음에 코드를 볼 사람을 위해 코드를 더 깔끔하게 정리하세요.

## CHAPTER 33. 결론

- Tidy First? (코드 정리가 먼저인가?) 에 대한 질문
- 아래 네 가지 힘에 의해 영향을 받는다.

- 1. 비용 : 코드를 정리하면 비용이 줄까?
- 2. 수익 : 코드를 정리하면 수익이 더 커질까?
- 3. 결합도 : 코드를 정리하면 변경에 필요한 요소의 수가 줄어드나?
- 4. 응집도 : 코드를 정리하면 변경을 더 작고 좁은 범위로 집중시켜 더 적은 수의 요소만 다룰 수 있을까?

- 가장 중요한 것은 우리다. 주체적으로 일하자.

- 코드 정리에 너무 집착하지 말자.

- 결합도는 하나의 코드 정리 작업이 다음 코드 정리 작업으로 이어지게 한다.
- 코드 정리를 하고 나면 다음 정리를 하고 싶은 충동이 생기겠지만, 억제해야 한다.

- 스스로 코드 정리 연습을 하면서 다른 사람들을 대신하여 설계할 준비를 하고 있다는 것을 명심하자.

| 누가?      | 언제?        | 무엇을?    | 어떻게?      | 왜?       |
|----------|------------|---------|-----------|----------|
| 나        | 몇 분에서 몇 시간 | 코드 정리   | 구조나 동작 변경 | 결합도와 응집도 |
| 나와 팀원들   | 몇 일에서 몇 주  | 리팩토링    | 주간 단위 계획  | 멱법칙      |
| 모든 이해관계자 | 몇 달에서 몇 년  | 아키텍쳐 진화 | 동적 균형     | ?        |

- 소프트웨어 설계가 인간관계 속에서 벌어지는 진솔한 활동이 될 수 있도록 하자는 것이 취지이다.