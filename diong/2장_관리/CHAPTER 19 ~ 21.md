# 관리 - CHAPTER 19 ~ 21

19. 계속 코드 정리를 한다면, 대부분의 변경 작업은 이미 정리된 코드 안에서 이루어지게 된다. 따라서 코드 정리는 몇 분에서 한 시간 정도면 충분하다.

20. 정리한 코드와 변경할 동작이 함께 얽혀버린 경우, 진행 중인 작업을 버리고 코드 정리를 선행하는 순서로 다시 시작하는 것을 고려해볼 수 있다.

21. 상황에 따라 다른 코드 정리 시점을 고려할 수 있다.

- 코드 정리를 하지 말자.

  - 앞으로 다시는 코드를 변경하지 않을 때
  - 설계를 개선하더라도 배울 것이 없을 때

- 나중으로 정리를 미루자.

  - 정리할 코드 분량이 많은데, 보상이 바로 보이지 않을 떄
  - 코드 정리에 대한 보상이 잠재적일 때
  - 작은 묶음으로 여러 번에 나눠서 코드 정리를 할 수 있을 때

- 동작 변경 후에 정리하자.

  - 다음 코드 정리까지 기다릴 수록 비용이 더 불어날 때
  - 코드 정리를 하지 않으면 일을 끝냈다는 느낌이 들지 않을 때

- 코드 정리 후에 동작 변경을 하자.

  - 코드 정리를 했을 때, 코드 이해가 쉬워지거나 동작 변경이 쉬워지는 즉각적인 효과를 얻을 수 있을 때
  - 어떤 코드를 어떻게 정리해야 하는지 알고 있을 때

---

### 🚀 CHAPTER 19. 리듬

코드 정리를 관리하는 기술 중에는 정리의 리듬을 관리하는 일도 있다.

코드 정리할 때 한번에 처리하는 규모를 작게할 것을 권했다. 특정 동작 변경 이전에 수행한 일련의 구조 변경에 얼마나 많은 시간이 소요될까?

- 소프트웨어 설계는 프랙탈(fractal = 작은 구조가 전체 구조와 비슷한 형태로 끝없이 되풀되는 구조)이므로 설계는 크게도 작게도 할 수 있다. 하지만, 이 책의 목적에 따라 소프트웨어 설계에 대한 한 가지 척도를 제시한다.

- 바로 **개인에게 영향을 미치는 소프트웨어 설계**다.

- 그래서 분 단위를 유지하되, 한시간을 넘지 않는다.

- 한 번의 코드 정리에 한 시간 이상이 걸린다면, 이는 원하는 동작 변경을 위해 필요한 최소한의 구조 변경 시기를 놓쳤다는 의미일 수 있다.

또 다른 가능성도 있다. 코드가 너무 엉망이라서 동작 변경에 앞서 몇 시간을 들여서라도 코드 정리를 선행하는 것이 더 유리할 수 있다.

- 그 말이 사실이라 하더라도, 오래 지속될 수는 없는 노릇이다. 소프트웨어 설계는 '길을 닦는' 일의 성격이 매우 강하기 때문이다.

> "한 대학에서 건물을 여러개 지었는데, 기획자들은 건물을 거의 다 지었을 때에도 건물 사이에 통행로를 어디에 만들지 정하지 못했다. 그러나 그들은 시간을 들이면서 신중하게 추측하는 대신에 건물과 건물 사이의 모든 공간에 잔디를 심었다. 몇달 후, 학생들이 밝도 다녀서 잔디밭이 닳아 없어진 부분이 생겨났다. 기획자들은 닳아 없어진 부분을 매끄럽게 포장했다."

**동작 변경은 코드 안에 뭉쳐서 나타나는 경향이 있다.**

- 파레토 법칙에 따르면 80%의 변경 사항이 20%의 파일에서 발생한다.

- 코드 정리를 선행할 때, 탁월한 장점 중에는 코드 정리 내용도 뭉쳐진다는 것이다.

- 그리고 코드 정리가 코드를 뭉친 결과는 정확하게 동작 변경하기에 가장 좋은 위치에서 뭉쳐져 있다.

처음에는 코드 정리를 많이 하는 경우조차 머지않아 이미 정리를 끝낸 코드로 동작 변경을 진행하고 싶어 하는 자신을 발견할 수 있다.

- 그리고, **계속 코드 정리를 한다면, 대부분의 변경 작업은 이미 정리된 코드 안에서 이루어지게 된다.**

- 결국 시스템에 있는 대부분의 코드에 손을 대지 않았음에도, 정리되지 않은 코드를 만나는 일이 급격하게 줄어든다.

그렇기 때문에 **코드 정리는 몇 분에서 한 시간 정도면 충분하다**고 자신 있게 말한다.

- 때로는 더 긴 경우도 있을 것이다. 그러나 그리 길지는 않을 것이다.

> "청소를 자주 하면, 한 번에 많은 시간을 들여 대청소할 필요가 없다."

---

### 🚀 CHAPTER 20. 얽힘 풀기

어떤 코드의 동작 변경을 하고 있다고 가정하자. 이때, 변경을 쉽게 할 코드 정리를 알고 있다. 그래서 코드 정리를 진행한다. 그래서 코드 정리를 진행하고, 그런 다음 새로운 테스트 케이스를 작성한다. 이제 동작을 변경해야 한다. 그랬더니 코드 정리할 곳이 더 생겼다. 이렇게 한 시간을 씨름하고 난 결과...

- 변경 대상인 동작을 모두 알게 되었고

- 그 동작을을 쉽게 변경하려면, 어떤 코드를 정리해야 하는지 모두 알게 되었으나

- 문제는 정리한 코드와 변경할 동작이 함께 얽혀 버렸다.

세 가지 선택이 있지만, 그 중 어느 것도 매력적이지 않다.

- 그대로 배포할 수 있다. 검토하는 사람들이 무례하다 느끼고, 오류가 발생하기 쉽지만 당장 처리할 수 있다.

- 코드 정리와 변경 사항을 별도의 하나 이상의 PR로 나누거나 하나의 PR을 여러 번의 커밋으로 나눌 수 있다. 이 방법으로 무례함은 줄일 수 있지만 작업 횟수는 늘어난다.

- **진행 중인 작업을 버리고, 코드 정리를 선행하는 순서로 다시 시작할 수 있다. 이렇게 하면 작업은 더 많아지지만, 이어지는 커밋과의 일관성은 분명해진다.**

매몰 비용의 오류로 셋 중에 하나를 선택하는 일이 복잡해진다. 이미 통과한 새로운 테스트가 몇 개 있는데, 그걸 왜 버려야 하나?

- 대답은 항상 같다. 우리가 작성하는 코드는 컴퓨터에 지시할 뿐 아니라, 컴퓨터에 지시하려는 의도를 사람들에게 설명해야 하기 때문이다.

- 컴퓨터에 지시만 하는 빠른 수행이 흥미로운 최종 목표가 되는 것은 아니다.

이쯤 되면 세 번째 선택지를 실험해 보라고 권하는 것이 그리 놀랍지 않을 것이다.

- 다시 구현하면서 새로운 것을 발견할 가능성이 높아진다.

- 그리고 동일한 동작 변경을 하면서도 더 많은 가치를 끌어낼 수 있다.

실타래를 풀려먼 실이 엉켜 있다는 사실을 알아차려야 시작할 수 있다. 따라서 실타래를 풀어야 할 필요성을 더 일찍 깨달을수록 작업량은 적어질 것이다.

처음으로 코드 정리를 하기로 마음먹고 진행하다 보면, 먼저 정리할 것인지 나중에 정리할 것인지 고민하다가 코드 정리와 동작 변경 사이에서 전환 시점을 놓치기 일쑤일 것이다.

- 즉, '순조롭게 코드를 고치고 있다'고 느꼈는데, 이내 '이런, 내가 뭘 한 거야?'라며 난감해질 수 있다.

- 그러나 **걱정하지 말자. 코드 정리와 동작 변경 사이의 선후 문제는 보통 시간이 지나면 해결될 테니까.**

---

### 🚀 CHAPTER 21. 코드 정리 시점

코드 정리를 먼저 하고 나서, 동작 변경을 할까? 아니면 동작 변경을 먼저 한 후, 코드 정리를 할까? 아니면 이후 동작 변경에 어려움이 가중될 수 있으니 혼란스러운 부분을 메모로 남기고 정리는 나중으로 미룰까? 그것도 아니면 아예 코드 정리를 하지 않는게 좋을까?

### 1. 아예 안 한다면

언제 다음 같은 말을 할까? "그래, 이건 엉망진창이지만. 이 코드는 변경하지 않기로 결정했어."

- 이 경우, 가장 그럴듯한 이유는 코드의 동작이 앞으로 바뀌지 않을 거라는 믿음이다.

코드의 동작을 변경할 필요가 전혀 없는 경우는 극히 드물지만, 실제로 일어나는 경우가 있다.

진짜로 변경이 필요 없는 시스템이라면 "고장 나지 않으면 고치지도 말자"는 마링 합리적으로 통한다.

### 2. 나중에 정리하기

나중에 코드를 정리하겠다는 선택을 마치 정답처럼 여겨도 되는 이유는 지금 정리할 코드가 너무 많으니 언제 해도 상관없다는 논리다.

정말 나중에 정리해도 무방하다. 하지만 마음에 들지 않을 전제 조건이 있다.

- 일을 할 시간은 충분한가? 단순히 충분한 시간이 있는지 묻는 것이 아니다. 물론, 없을테니까.

- 주어진 시간보다 할 일이 더 많은지 묻는 것도 아니다. 물론, 많을테니까.

- **'시간이 충분하다면 어떻게 일할 것인가?'라고 스스로 물어보자. 그 대답이 실제로 하고 있는 일과 크게 다르다면, 일할 시간이 충분하지 않다는 뜻이다.**

그러나 일할 시간이 충분하지 않다고 말하는 가정을 면밀히 조사해 봤으면 한다.

일시적으로, 잠정적으로 업무를 처리할 시간이 충분히 주어진다면 어떻게 할까?

- 나중에 정리할 목적으로 엉망인 코드 목록을 만들 수도 있다. ('재미 목록'이라 부르겠다.)

- 그러면 나중에 다음 기능 구현을 할 때 정신없는 코드 변경으로 허우적거리기보다는 재미 목록을 훑어보면서 '한 시간이 남았군. 큰일은 건드리지 말아야 하니까. 4번 항목부터 시작해 볼까?'라고 생각할 수 있다. 그리고 진행하면 되겠지.

물론 먼저 코드 정리를 해 놓으면, 나중에 시스템 동작 변경을 더 쉽게 한다.

- 시스템에서 반드시 변경할 거라고 보장할 정도면, 그 보편적 영역을 정리하는 것만으로 향후 변경을 단순화하는 가치가 창출된다.

정리를 나중에 하는 일, 다시 말해 지금 변경한 동작과 연결되지 않는 코드 정리를 나중에 하면 몇 가지 다른 방식으로 가치를 창출한다.

- 한 가지는 지저분함 보유세를 줄이는 것이다. 이전 API에서 새 API로 바뀌는 과정을 생각해 보자.

  - 당장 영향을 받는 API 호출 코드는 변경했지만, 나중에 변경을 반영해야 할 곳이 100개 더 있다.

  - 물론 변경을 모두 완료한 후에는 이전 API를 제거해도 된다.

  - 하지만 그때까지는 새 API에 변경 사항이 발생하면, 거울처럼 이전 API에도 똑같이 반영해야 하는 불편함이 있다.

호출하는 모든 코드를 정리하는 일은 무의미하지 않다.

- 새로운 API 전환에 따라 영향을 받는 코드 모두를 변경하고 나면, 어떤 클래스들은 변경하기가 훨씬 쉬워진다.

- 코드를 정리해야 할 필요성은 크지 않지만, 당장 신발 안에 든 작은 조약돌을 빼내면 걸음을 더 잘 걸을 수 있게 되는 것과 같은 이치다.

코드 정리를 나중에 할 근거 중 다른 하나는 학습 도구로 활용하는 것을 들 수 있다.

- 코드는 자신이 어떻게 구조화되고 싶은지 '알고'있다.

- 만약에 코드에 귀 기울이면서 현재 구조에서 원하는 구조로 옮기다 보면 무언가를 반드시 배우게 된다.

- 코드 정리는 설계한 세부 결과를 깨달을 수 있는 좋은 방법이다. 생각할 수 있는 설계를 비춰준다.

### 3. 동작 변경 후에 코드 정리

동작을 변경해야 하는데, 코드가 지저분하다. 여하튼 동작을 변경한다. 이제 코드를 정리해야 할까?

- 상황에 따라 다르다. 변경한 코드를 대상으로 다시 동작 변경을 하게 될까? 아마 그럴 가능성이 높다.

- 그래도 스스로의 판단이 먼저다. 같은 영역을 다시 변경해야 된다면, 동작 변경 후 코드 정리하는 일은 상당히 의미가 있다.

다음 번 동작 변경을 할 때, 코드 정리부터 먼저 하는 것은 어떨까?

- 나중에 가면 정리하는 일이 더 힘들 수도 있다.

- 지금은 맥락을 알아서 쉽게 정리할 수 있는 일이지만, 나중에는 맥락을 잊어버릴 수 있기 때문이다.

- 또는 다른 변경 건이 생겨 코드 정리를 하는 데 훼방을 놓을 수도 있다.

- **나중에 코드를 정리할 때까지 기다리느라 비용이 너무 많이 증가할 가능성이 있다면, 지금 정리하는 것이 좋다.**

그런데, 정리는 어느 정도나 해야 할까? 동작 변경에 한 시간이 걸렸다고 가정해보자.

- 그렇다면, 한 시간 정도 코드 정리에 투자하는 것이 합리적이다.

- 만약 일주일이라면? 그건 말이 안된다. 그럴 일이라면 그냥 재미 목록에 추가하자.

**다음의 경우라면 동작 변경 후 코드 정리를 하자.**

- 방금 고친 코드를 다시 변경할 예정일 때

- 지금 정리하는 것이 더 저렴할 때

- 코드 정리하는 데 드는 시간이 동작 변경에 드는 시간과 거의 비슷할 때

### 4. 코드 정리 후에 동작 변경

코드 정리를 선행해야 할까? 상황에 따라 다르다. 무엇에 따라 다를까? 스스로에게 이런 질문을 해보자.

- 지저분한 상태 그대로 코드를 변경한다면, 일이 얼마나 더 어려운가?

  - 코드를 정리한다고 해서 더 쉬워지지 않는다면, 먼저 정리하지 말자.

- 코드 정리의 이점을 바로 얻을 수 있는가?

  - 아직 동작 변경 준비가 되지 않았다고 가정해 보자. 이해하고자 코드를 읽고 있는 중이다.
  - 코드를 정리하여 더 빨리 이해할 수 있깄다고 판단이 서면, 먼저 코드 정리를 하자.

- 코드 정리에 드는 비용을 어떻게 보상받을 수 있을까?

  - 이 코드를 딱 한 번만 변경할 예정이라면 코드 정리는 제한하는 것이 좋다.
  - 코드 정리로 몇 년 동안 매주 보상받는다면 먼저 하는 것이 좋다.

- 코드 정리에 대해 얼마나 확신하고 있나?

  - 추측할 때는 편견에서 벗어나야 한다. '이 것만 없어도 변경하기 쉬울텐데' 그러니 다른 한편으로, '여기를 정리하면 이해하기 쉬워질 거야. 내가 지금 혼란스러운 걸 보면 알 수 있지'

**일반적으로 코드를 먼저 정리하는 것을 선호하지만, 정리 그 자체를 목적으로 삼지 않도록 경계해야 한다.**

- 코드 정리를 했는데 당장 효과를 못보더라도 크게 문제가 안된다.

- 코드 정리 선행을 좋아해도, 보통 대가가 크지 않고, 대부분은 보상을 받을 것이다.

### 요약

다음 상황에는 코드 정리를 하지 말자.

- 앞으로 다시는 코드를 변경하지 않을 때

- 설계를 개선하더라도 배울 것이 없을 때

다음 상황에서는 나중으로 정리를 미루자.

- 정리할 코드 분량이 많은데, 보상이 바로 보이지 않을 떄

- 코드 정리에 대한 보상이 잠재적일 때

- 작은 묶음으로 여러 번에 나눠서 코드 정리를 할 수 있을 때

다음 상황에서는 동작 변경 후에 정리하자.

- 다음 코드 정리까지 기다릴 수록 비용이 더 불어날 때

- 코드 정리를 하지 않으면 일을 끝냈다는 느낌이 들지 않을 때

다음 상황에서는 코드 정리 후에 동작 변경을 하자.

- 코드 정리를 했을 때, 코드 이해가 쉬워지거나 동작 변경이 쉬워지는 즉각적인 효과를 얻을 수 있을 때

- 어떤 코드를 어떻게 정리해야 하는지 알고 있을 때
