# 코드 정리법 - CHAPTER 01 ~ 07

1. `if`의 중첩 또는 `else if`, `else` 사용보다는 보호 구문(`if ... return`)을 사용하자.

2. 안 쓰는 코드는 과감히 지워 버리자.

3. 한 가지 코드 패턴을 선택해서 정하자. 다른 방식으로 작성한 코드를 선택한 방식으로 고치자.

4. 기존 인터페이스 때문에 복잡하다면, 기존 인터페이스를 호출하는 인터페이스를 새롭게 구현하자.

5. 나와 다른 사람을 위해 읽기 좋은 순서로 코드를 정렬하자.

6. 코드의 순서를 바꿔서 변경할 요소들을 가까이 두자. (= 결합도가 있으면 서로 옆에 두자)

7. 변수를 사용하기 직전에 선언하고 초기화하자.

---

### 🚀 CHAPTER 01. 보호 구문

```js
if (조건)
  ...코드...

if (조건)
  if (다른 조건 부정)
    ...코드...
```

이런 코드를 읽을 떄면 중첩된 조건은 헷갈린다. 그래서 코드를 다음과 같이 정리할 수 있다.

```js
if (조건 부정) return
if (다른 조건) return
...코드...
```

더 읽기 쉬워졌다. 이는 마치 "코드의 세부 사항을 살펴보기 전에 염두에 두어야 할 몇 가지 전제 조건이 있습니다"라고 말하는 것처럼 보인다.

다만, 보호 구문을 남용하지는 말자. 7, 8개의 보호 구문이 있는 루틴을 보면 읽기가 매우 까다롭다.

복잡한 코드를 경우에 맞춰 나누려면 세심한 주의가 핋요하다.

조건에 딱 부합하는 경우를 만나면 보호 구문을 넣어 코드를 정리하자.

```js
if (조건)
  ...루틴의 나머지 모드 코드...
```

정리하고 싶은데 정리할 수 없는 코드가 보이면,

```js
if (조건)
  ...코드...
...다른 코드...
```

처음 두 줄을 도우미(helper) 메서드로 추출한 다음에 보호 구문으로 코드를 정리할 수도 있지만, **항상 그리고 반드시 작은 단계를 거쳐 코드를 정리하자.**

---

### 🚀 CHAPTER 02. 안 쓰는 코드

**지워 버리자. 실행되지 않는 코드리면 그냥 지우자.**

안 쓰는 코드를 지운다는 것은 매우 낯설게 느껴질 수 있다.

- 이 코드를 작성하느라 노력한 사람도 있었을 테고, 조직도 이를 위해 투자했을 테니까.

- 누군가 이 코드를 다시 호출하는 일이 있을 수 있고.

- 다시 필요하게 되면, 삭제한 것을 나중에 후회할 수도 있다.

때로는 안 쓰는 코드 찾기가 쉬울 수도 있지만, 더러는 쉽지 않을 떄도 있다.

만약에 코드가 쓰이고 있지 않다고 생각되면, 로그를 활용해 지우고 나서 다시 실행해서 확인해 보자. 사용자에게 배포한 후에 확인이 설때까지 기다려보자.

"지웠다가 나중에 필요할 경우 어떡하지?"라고 말할 수도 있다. 이런 걱정이라면 형상 관리 도구가 해결해 준다.

지운 코드는 다시 가져올 수 있고, 그냥 다시 작성하는 편이 더 나을 수도 있다. 어쨌든 최악의 상황이 오더리도 언제든 되돌릴 수 있다.

---

### 🚀 CHAPTER 03. 대칭으로 맞추기

코드는 마치 유기체처럼 성장한다. 같은 문제라도 시대와 사람에 따라 다른 모습으로 해결된다.

자연스러운 일이지만, 이것은 코드를 읽기 어렵게 만들기도 한다.

**읽는 입장에서는 일관성이 중요하다.** 패턴이 보일 경우, 진행되는 것을 알 수 있으니까 확인을 가지고 바로 결정할 수 있다.

```js
function foo() {
  if (x is null) {
    x = ...;
  }
  return x;
}

function foo() {
  if (x is null) x = ...;
  return x;
}

const foo = () => {
  if (x is null) {
    x = ...;
  }
  return x;
}

const foo = () => {
  if (x is null) x = ...;
  return x;
}
```

위의 각 코드가 뜻하는 바는 같다. 한가지 패턴의 코드는 읽다 보면 그 방식에 금방 익숙해지지만, 두가지 이상의 패턴을 섞어 쓰면 혼란스러워진다.

코드를 읽을 때 기존과 다르다면 '다른 동작의 코드겠지'라고 예단할 수 있다. 여기서 차이가 있다 보니, 같은 일임에도 다른 일인 것처럼 뜻이 흐려진다.

**한 가지 방식을 선택해서 정하자. 다른 방식으로 작성한 코드를 선택한 방식으로 고치자.**

때로는 공통성이 있는데도 세부 사항에 묻혀 드러나지 않는다. 비슷해 보이지만 같이 않은 루틴을 찾아내자. 그러고 나서 같은 부분들 속세 다른 부분이 끼어 있다면 분리하자.

---

### 🚀 CHAPTER 04. 새로운 인터페이스로 기존 루틴 부르기

루틴을 호출해야 하는데 기존 인터페이스 때문에 어렵거나, 복잡하거나, 혼란스럽거나, 지루해지곤 한다.

이 모든 경우에 **호출하고 싶은 인터페이스를 새롭게 구현해서 호출하자. 새로 만든 인터페이스는 그거 기존 인터페이스를 호출하는 것으로 구현할 수 있다.**

- 기존 인터페이스를 호출하는 코드를 새 인터페이스를 호출하도록 모두 이전한 후에는 이전 인터페이스를 제거하고 새 인터페이스가 직접 루틴을 구현하도록 변경할 수 있다.

새롭게 구현한 통로 인터페이스(pass-through interface)는 소프트웨어 설계에서 작은 단위로 중추적 역할을 한다.

어떤 동작을 변경해야 할 때가 왔을 때, 통로 인터페이스를 이용해 설계를 했다면 변경하기가 한층 더 수월하다.

다음의 경우에도 통로 인터페이스 적용 때와 비슷한 느낌을 받을 것이다.

- 거꾸로 코딩하기: 루틴의 마지막 줄부터 시작해 보자. 이때는 마치 마지막 줄에 이르기까지 필요한 결과는 모두 확보한 듯이 짠다.

- 테스트 우전 코딩: 테스트부터 작성하여 통과 요건을 정한다.

- 도우미 설계: 만일 나에게 특정 업무를 해주는 루틴, 객체, 서비스가 있다면 나머지 작업은 쉬워진다.

---

### 🚀 CHAPTER 05. 읽는 순서

읽기 좋은 순서로 코드를 정렬하면, 그 순서대로 코드를 만날 수 있다.

- 여러 사람이 작성한 내용을 서로 보게 된다는 사실을 기억하자.

코드를 읽을 때는 독자의 입장이 되어보자.

**다른 코드 정리 작업을 함께 하고픈 유혹이 오더라도 뿌리치자.**

- 읽어 가면서 이해나 변경을 어렵게 하는 세부 사항들도 주목했을 텐데, 나중에 이들을 정리할 때가 있다.

- 다른 대안으로, 지금 발견한 세부 사항을 정리하고, 읽는 순서로 만드는 일은 다음 정리에서 하면 된다. 섞으면 안된다.

언어에 따라서는 요소를 선언하는 순서에 민감하게 반응하는 경우도 있다.

- 즉, 함수 A와 함수 B의 선언 순서를 바꾸기만 해도 실행 결과가 달라진다.

- 이러한 언어에서는 주의해야 한다. 되도록 전체 파일의 순서를 바꾸는 대신에, 읽는 순서가 영향을 크게 주는 것들부터 바꾸자.

완벽한 순서는 없다.

- 때로는 기본 요소를 먼저 이해한 다음 구성 방법을 이해하고 싶을 때가 있고, API를 먼저 이해한 다음 세부 구현을 이해하고 싶을 때도 있다.

- **스스로가 코드를 읽어 왔을 테니 최근 경험을 살려 판단하자.**

어떤 순서의 코드가 제일 좋을까? 코드를 읽는 다음 사람에게 그렇게 정렬된 코드를 선물하자.

---

### 🚀 CHAPTER 06. 응집도를 높이는 배치

코드를 읽다가 변경해야 할 동작을 찾았더니 여러 곳애 흩어져 있는 코드를 함께 바꿔야 한다는 걸 알면 불편한 감정이 일어난다.

그럴 때는 어떻게 해야 할까? **코드의 순서를 바꿔서 변경할 요소들을 가까이 두면 된다.**

이 정리 방법은 하나의 파일 속에는 다음과 같이 해당한다.

- 두 루틴에 결합도가 있으면 서로 옆에 두자.

- 한편, 같은 디렉토리에 들어있는 파일에도 적용할 수 있다.

- 두 파일에 결합도가 있으면 같은 디렉토리에 넣는다.

- 코드 저장소 너머 작동할 수도 있다. 결합도가 있는 코드를 같은 코드 저장소에 넣은 후 변경하자.

왜 결합도를 제거하지는 않는 걸까? **결합도를 제거할 수 있다면 그렇게 하자.**

- 아래 가정을 보면, 이것이 가장 좋은 코드 정리법이다.

- 결합도 제거 비용 + 변경 비옹 < 결합도에 따른 비용 + 변경 비용

하지만 여러가지 이유로 결합도 제거가 어려울 수 있다.

- 당장 어떻게 해야 할지 모른다면 결합도 제거가 곤란할 수 있다.

- 할 수 있더라도 지금 당장은 시간적 여유가 없다면 결합도 제거는 부담스러운 시간 투자가 된다.

- 팀이 이미 충분한 변경을 수행하고 있다면 결합도를 제거하는 일이 팀원 간의 잠재적 갈등으로 번질 수 있다.

스위스 치즈처럼 여기저기 코드가 구멍 난 듯 흩어진 채로 두고 동작 변경에만 매달리지 말자.

응집도를 높이는 순서를 정리하면, 코드를 더 쉽게 변경할 수 있다.

때로는 응집도를 조금 개선해서 코드가 명확해지면, 결합도 제거를 막고 있던 장막이 걷힐 수도 있다.

그리고 응집도가 좋아지면 결합도 역시 덩달아 좋아진다.

---

### 🚀 CHAPTER 07. 선언과 초기화를 함께 옮기기

변수 선언과 초기화 위치는 종종 서로 떨어져 있기도 한다. 보통 변수 이름에서 힌트를 얻어 프로그램에서 역할을 알게 되지만, 변수 초기화는 이름이 주는 의미를 더 강화한다.

코드를 읽는데, 타입이 포함된 선언과 초기화 코드가 떨어져 있기라도 하면 읽어 내기는 더 어려워진다. 한참 뒤에야 초기화 코드를 보게 된다면, 이미 변수가 어떤 맥락에서 선언되었는지 잊어버릴지도 모르니까.

```js
function fn() {
  let a;

  ...변수 a를 사용하지 않는 코드

  a = ...;
  let b;

  ...변수 a를 사용할 수 있으나 변수 b를 사용하지 않는 코드

  b = ...a...;

  ...변수 b를 사용하는 코드
}
```

초기화를 변수 선언 근처로 이동하여 위 코드를 정리해보자.

```js
function fn() {
  let a = ...;

  ...변수 a를 사용하지 않는 코드
  ... 변수 a는 사용하고 변수 b는 사용하지 않는 코드

  let b = ...a...;

  ...변수 b를 사용하는 코드
}
```

**변수를 사용하기 직전에 선언하고 초기화**하는 경우가 함수 맨 위에 모든 변수를 함께 선언하고 이후에 초기화하는 경우보다 더 코드를 읽고 이해하기 쉽다.
