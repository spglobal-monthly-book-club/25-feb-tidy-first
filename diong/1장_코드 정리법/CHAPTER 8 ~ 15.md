# 코드 정리법 - CHAPTER 08 ~ 15

8. 전체에서 일부 표현식을 추출한 후, 표현식의 의도가 드러나도록 변수 이름을 만들어 할당하자.

9. 상징적인 상수를 만들자. 리터럴 상수로 사용된 곳은 상징적인 상수로 바꾸자.

10. 일부 데이터가 명시적으로 전달되지 않는다면, 앞부분에서 매개변수 값을 채운 후 뒷부분에서 명시적으로 전달하자.

11. 코드 구분이 될 때는 두 부분 사이에 빈 줄을 넣어 분리하자.

12. 나머지 코드와 상호작용이 적은 코드 블록을 추려내고, 도우미(helper)로 추출한 후에 이름을 붙이자.

13. 필요한 만큼의 코드를 하나의 더미처럼 느껴질 때까지 흩어진 코드를 모으자.

14. 다른 사람의 관점에서 생각하며 코드에서 명확하지 않은 내용은 주석으로 설명하자.

15. 코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제하자.

---

### 🚀 CHAPTER 08. 설명하는 변수

코드의 어떤 표현식들은 계속 성장한다.

- 처음에는 작게 시작했더라도, 시간이 흐르면 코드는 반드시 커진다.

- 그러다가 돋보기까지 동원해야만 무슨 내용인지 알게 되는 지경에 이른다.

어렵게 크고 복잡한 코드의 표현식을 이해했다면 **전체에서 일부 표현식을 추출한 후, 표현식의 의도가 드러나도록 변수 이름을 만들어 할당해 보자.**

```js
return new Point(
  ...긴 표현식...,
  ...다른 긴 표현식...
);
```

이러한 표현식을 변경하기 전에 다음과 같이 코드 정리를 하면 설명하는 변수로 바뀐다.

```js
x = ...긴 표현식...;
y = ...다른 긴 표현식...;
return new Point(x, y);
```

또는 표현식 의미를 더 구체적으로 할 수도 있는데 예를 들면, 너비와 높이, 위쪽과 왼쪽, 뛰기와 오르기 따위를 변수명으로 쓰는 것이다.

이렇게 설명하는 변수를 적용하면 이제 표현식과 분리되었기 때문에 다음 번 코드를 변경할 때, 둘 중 하나만 읽으면 되니까 재빨리 변경할 수 있다.

언제나 그렇듯이, **코드 정리에 대한 커밋과 동작 변경에 대한 커밋은 분리해야 한다.**

---

### 🚀 CHAPTER 09. 설명하는 상수

코드를 일다가 모르는 숫자를 볼 때가 있다. 혹은 같은 상수 문자열이 코드 전체에서 반복해서 나타나기도 한다.

그러면, 상수가 무엇을 의미하는지 알아내야 한다.

**상징적인 상수를 만들자. 리터럴 상수로 사용된 곳은 상징적인 상수로 바꾸자.**

```js
if (response.code === 404) {
  ...코드...
}
```

아래 코드로 변경하자.

```js
const PAGE_NOT_FOUND = 404;
if (response.code === PAGE_NOT_FOUND) {
  ...코드...
}
```

같은 리터럴 상수가 두 곳에서 나타날 때는 다른 의미로 쓰이지는 않는지 주의하자. 그러니 다음과 같은 빈약한 의미를 가진 코드 정리는 도움이 되지 않는다.

```js
const ONE = 1;
...ONE... // 하나가 필요할 때 어디든 등장
```

먼저 코드를 읽고 이해하자. 그런 다음 이해한 내용을 코드에 넣어두면 힘들게 기억하지 않아도 된다.

이 코드 정리법에 뒤따르는 몇 가지 일들이 있다.

- 한번에 바뀌어야 하거나 함께 이해해야 하는 상수들을 한곳에 모아두고, 다른 이유로 묶인 변수들을 분리하는 후속 작업을 해야한다.

- 하지만 결합도와 응집도는 뒤로 하고, 일단 작업하자.

---

### 🚀 CHAPTER 10. 명시적인 매개변수

변경하려는 코드를 읽는 중에 루틴에서 다루고 있는 일부 데이터가 명시적으로 전달되지 않는 것을 발견했다. 이런 경우 입력을 명확하게 하려면 어떻게 해야할까?

**루틴을 나누자. 앞부분에서 매개변수 값을 채운 후, 뒷부분에서 명시적으로 전달한다.**

맵(map)에서 매개변수가 블록으로 전달되는 경우가 흔하다.

- 이렇게 하면, 코드를 읽으면서도 어떤 데이터가 필요한지 알기 어렵다.

- 또한, 이후에 매개변수를 변경하여 암묵적으로 사용하는 일과 같은 끔찍한 남용의 길이 열린다.

```js
const params = { a: 1, b: 2 };
foo(params);

function foo(params) {
  ...params.a... ...params.b...
}
```

`foo`를 나누면 명시적 매개변수 정리를 적용할 수 있다.

```js
function foo(params) {
  fooBody(params.a, params.b);
}

function fooBody(a, b) {
  ...a... ...b...
}
```

명시적인 매개변수가 필요한 또 다른 경우는 중괄호가 여러 개로 둘러싸인 코드에서 환경 변수를 사용하는 경우다.

- 매개변수를 명시적으로 드러나게 만든 다음, 함수를 연쇄적으로 호출할 수 있게 준비하자.

- 이렇게 만들면 코드는 읽기와 테스트, 분석이 쉬워진다.

---

### 🚀 CHAPTER 11. 비슷한 코드끼리

모든 코드 정리 중에서 가장 단순한 정리법이다. 긴 코드 덩어리를 읽다가 '아, 이 부분은 이렇게 하고, 저 부분은 저렇게 하는 구나'라고 **구분이 될 때는 두 부분 사이에 빈 줄을 넣어 분리하자.**

이 것은 이 책 '켄트 백의 Tidy First?'를 구성하는 철학의 일부다. 소프트웨어 설계가 큰일이되면, 설계 작업을 아예 그만두고 싶은 위험에 직면한다.

- 그러나 적절한 소프트웨어 설계는 변화를 가능하게 한다.

- 작은 소프트웨어 설계로 변화를 좀 더 쉽게 만들 수 있다.

소프트웨어 설계 또한 복리처럼 뒤따르는 소프트웨어 설계를 더 쉽게 만든다. 따라서 소프트웨어 설계는 양날의 검과 같다.

- 제대로 된 소프트웨어 설계는 유연성을 확보하지만,

- 그렇지 못한 경우는 자칫 변화 자체를 망각하고 설계의 소용돌이에 빠질 수 있다.

---

### 🚀 CHAPTER 12. 도우미 추출

코드를 보다가 루틴 속 코드 중에서, 목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 블록을 만날 때가 있다.

그 **코드 블록을 추려내고, 도우미(helper)로 추출한 후에 이름을 붙이자.**

- 이때, 도우미의 이름은 작동 방식이 아니라 목적에 따라 짓자.

도우미를 추출할 때, 몇 가지 특수한 경우가 있다.

**1. 큰 루틴 안에서 몇 줄을 변경해야 하는 경우**

- 해당하는 줄들을 도우미로 추출하고, 도우미 안의 내용만 변경한 다음, 적절하다고 판단한 뒤에 도우미를 호출하는 문장에 반영하자.

  ```js
  function routine() {
    ...그대로 두는 코드...
    ...바꾸려는 코드...
    ...그대로 두는 코드...
  }
  ```

  이렇게 바꾸자.

  ```js
  function helper() {
    ...바꾸려는 코드...
  }

  function routine() {
    ...그대로 두는 코드...
    helper();
    ...그대로 두는 코드...
  }
  ```

  이 작업은 응집도 높은 요소 만들기로 이해할 수 있다.

**2. 시간적 결합을 표현하는 경우**

- `a()`가 `b()`보다 앞서 호출되어야 하는 경우를 말한다.

  ```js
  foo.a();
  foo.b();
  ```

  이렇게 바꾸자.

  ```js
  function ab() {
    a();
    b();
  }
  ```

도우미를 만들다 보면, 몇 시간 혹은 몇 분 만에 다시 사용하고 싶어하는 자신의 욕구를 발견할 것이다.

이 과정에서 인터페이스는 문제를 생각하도록 이끄는 도구가 된다.

- 우리가 만든 설계 요소에 새로운 이름을 붙일 수 있을 때, 새로운 인터페이스가 떠오른다.

도우미는 필요한 모든 곳에서 사용할 수 있다. 도우미 사용은 또 다른 코드 정리에도 도움이 된다.

---

### 🚀 CHAPTER 13. 하나의 더미

때로는 코드가 여러 개의 작은 조각으로 나뉘어져 있기도 한다. 이렇게 **흩어져 있으면 코드를 전체적으로 이해하기가 어렵다.**

**필요한 만큼의 코드를 하나의 더미처럼 느껴질 때까지 흩어진 코드를 모으자.**

- 그러고 나서 깔끔하게 정리하자.

**코드를 만드는데, 가장 큰 비용이 들어가는 일은 코드 작성이 아니라 읽고 이해하는 데 드는 비용이다.**

- 코드 정리를 선행하면 더 작은 조각 단위로 결합을 제거하는 길을 제시하여 응집도를 높일 수 있다.

- 실무적으로는, 한 번에 머릿속에 기억하고 있어야 할 코드의 상세 내용을 줄여준다.

작은 코드 조각을 지향하는 목적은 코드를 한 번에 조금씩 이해할 수 있도록 하는 것이다. 하지만 때때로 이 과정이 잘못될 수 있다.

- 작은 코드 조각들이 서로 교류하는 방식은 코드를 더 알기 어렵게 한다.

- 명확성을 되찾으려면, 먼저 코드를 한데 모아서 이해하기 어려운 부분은 추출해서 새롭게 정리해야 한다.

다음 증상들을 찾아보자.

- 길고 반복되는 인자 목록

- 반복되는 코드, 그 중에서도 반복되는 조건문

- 도우미에 대한 부적절한 이름

- 공유되어 변경에 노출된 데이터 구조

---

### 🚀 CHAPTER 14. 설명하는 주석

코드를 읽다가 '아, 이건 이렇게 돌아가는 거구나!'라는 생각이 드는 순간을 알 것이다. 바로 그 순간이 소중한 순간이다. 기록하자.

**코드에서 명확하지 않은 내용만 골라 적자.**

- 코드를 읽기 15분 전, 미리 알았더라면 좋았을 점이 무엇인가?

- '다음은 네트워크 호출 횟수를 최대한 줄여야 하므로 다소 복잡해졌습니다'와 같이 기록할 수 있다.

나와 많이 다른 사람일지라도 특정한 누군가를 떠올리며 작성하자.

- **다른 사람의 관점에서 생각하고 예상되는 질문을 선제적으로 언급하려고 노력하는 것이다.**

코드의 결함을 발견했다면, 그 즉시 해당 위치에 주석을 달아햐 한다.

- `// 새로운 경우를 한개 더 추가하려면 foo를 반드시 변경해야 합니다.` 같은 주석이다.

- 물론 코드가 이런 식으로 결합되어 있는 것은 바람직하지 않다.

- 결국, 이를 제거하는 방법을 배워야 하겠지만, 그 때까지는 주석을 달아서 결합도 문제를 미리 지적해 두는 것이 그냥 두는 것보다 훨씬 나을 것이다.

---

### 🚀 CHAPTER 15. 불필요한 주석 지우기

**코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제하자.**

주석과 코드는 작성할 때와 나중에 볼 때, 시간이 흐르고 나면 서로 맞지 않는 경우가 있다.

보통 원하는 것을 말할 때, 신문으로는 잘 설명할 수 있다. 하지만 시스템이 변경될 때 신문으로 쓴 내용이 여전히 정확한지 이중으로 점검할 수 있는 장치가 없고, 코드가 변경될 경우에는 원래 있는 주석이 불필요해질 수 있다.

가끔은 소통 의무에 대해 편협한 시각을 가진 이들이 모든 루틴에 주석을 달아햐 한다는 식의 독단적인 규칙을 고집하기도 한다.

- 그런 경우 다음과 같은 주석이 달린다.

  ```js
  function getX() {
    // return X
    return X;
  }
  ```

  이 주석은 혜택은 없고 비용만 발생시킬 뿐이다. 그저 읽는 사람의 시간만 뺏는다.

- 주석이 완전한 중복이라면 삭제하자.

코드 정리는 종종 서로 연결되어 있다. 이전에 정리한 작업 결과가 남아있어 주석이 중복되기도 한다.

```js
if (generator) {
  ...generator 설정을 위한 코드...
} else {
  // generator가 없다면 default 반환
  return getDefaultGenerator();
}
```

조건절에 보호 구문을 적용해 정리한 후에는 다음과 같이 바뀐다.

```js
if (!generator) {
  // generator가 없다면 default 반환
  return getDefaultGenerator();
}
...generator 설정을 위한 코드...
```

처음에는 주석이 중복된 것은 아니었다. 하지만 바뀐 코드에서는 `generator`가 빠졌으므로 그에 맞추어야 한다.

- 이전 코드에는 `generator`가 있었고, 설정이 필요하니까 여러 줄의 코드가 나오고, 뒤이어 주석이 있었다.

- 코드를 정리하고 나서 보니, 주석은 코드 내용을 그대로 반복하고 있다.

- 그러니 삭제하자.
