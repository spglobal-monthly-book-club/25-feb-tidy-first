# 핵심정리

## 결합도와 응집도

### 모듈화와 모듈

프로그래밍을 할 때 생기는 문제가 복잡하고 크다면, 문제를 작은 부분으로 쪼개어서 하나씩 풀어나가게 될 것인데, 이 때 문제를 작은 부분으로 쪼개나가는 것을 **모듈화** 라고 함.

**모듈**은 소프트웨어를 각 기능별로 나눈 소스 단위를 말함. 하나의 함수 또는 클래스도 모듈이 될 수 있음.

### 결합도 란?

* 모듈과 모듈간의 의존 정도
* 결합도가 높은 경우 (BAD)
  * 어떤 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우
* 결합도가 낮은 경우 (GOOD)
  * 모듈간의 인터페이스로 전달되는 파라미터를 통해서만 상호 작용이 일어나는 경우

### 응집도 란?

* 한 모듈 내의 구성 요소들 간의 연관 정도
* 응집도가 높은 경우 (GOOD)
  * 한 모듈이 하나의 기능을 갖고 있는 경우
* 응집도가 낮은 경우 (BAD)
  * 한 모듈이 여러 기능을 갖고 있는 경우
  * 모듈 내부의 각 구성요소들이 연관이 없을 경우

응집도를 높이는 순서로 코드를 정리하면 결합도 역시 덩달아 좋아지기 때문에 더 쉽게 정리할 수 있다.



따라서 **높은 응집도**와 **낮은 결합도**가 이상적인 소프트웨어 모듈이게 된다.

![image-20250224015639777](C:\Users\juns5\AppData\Roaming\Typora\typora-user-images\image-20250224015639777.png)

응집도를 높이고 결합도를 낮추기 위한 원칙으로 설정되고 구성된 요소가 바로 객체지향 **디자인 패턴**이다.



## 주석

* 주석을 작성해야 하는 경우
  * 코드에서 명확하지 않은 내용이 있는 경우
  * 코드의 결함을 발견 하는 경우
    * ex) skeleton 필요 등...
* 주석을 삭제해야 하는 경우
  * 코드만으로 내용을 모두 이해할 수 있는 경우
  * 코드와 완전한 중복을 가진 주석



## 코드 정리 구분

* 코드 정리는 별도의 MR로 만들고, 가급적 MR당 몇 개의 코드 정리만 넣어야 함.
* 순서가 있는 일련의 코드 정리는(심지어 하나의 정리만 있더라도) MR 한 개로 만들어야 함.
* 코드 저일와 동작 변경 사이를 번갈아 가면서 전환할 때마다 새 MR을 열어야 함.
* 작은 규모의 MR은 리뷰어의 검토 시간 단축으로 환영받을 수 있음.

## 코드 정리 시점

* 동작 변경 후 코드 정리를 해야 하는 경우
  * 방금 고친 코드를 다시 변경할 예정일 때
  * 지금 정리하는 것이 더 저렴할 때
  * 코드 정리하는 데 드는 시간이 동작 변경에 드는 시간과 거의 비슷할 때
* 코드 정리 후 동작 변경을 해야 하는 경우
  * 코드 정리를 했을 때, 코드 이해가 쉬워지거나 동작 변경이 쉬워지는 즉각적인 효과를 얻을 수 있을 때
  * 어떤 코드를 어떻게 정리해야 하는지 알고 있을 때
* 코드 정리를 하지 않아도 되는 경우
  * 앞으로 다시는 코드를 변경하지 않을 때
  * 설계를 개선하더라도 배울 것이 없을 때
* 코드 정리를 나중으로 미뤄도 되는 경우
  * 정리할 코드 분량이 많은데, 보상이 바로 보이지 않을 때
  * 코드 정리에 대한 보상이 잠재적일 때
  * 작은 묶음으로 여러 번에 나눠서 코드 정리를 할 수 있을 때